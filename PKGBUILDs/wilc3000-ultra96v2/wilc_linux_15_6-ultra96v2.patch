diff --git a/drivers/net/wireless/microchip/wilc1000/Makefile b/drivers/net/wireless/microchip/wilc1000/Makefile
index 64c39aac1..0433772ef 100644
--- a/drivers/net/wireless/microchip/wilc1000/Makefile
+++ b/drivers/net/wireless/microchip/wilc1000/Makefile
@@ -1,5 +1,5 @@
 # SPDX-License-Identifier: GPL-2.0
-ccflags-y += -I$(src)/ -DWILC_DEBUGFS
+ccflags-y += -I$(src)/
 
 wilc-objs := cfg80211.o netdev.o mon.o \
 			hif.o wlan_cfg.o wlan.o sysfs.o power.o bt.o debugfs.o
diff --git a/drivers/net/wireless/microchip/wilc1000/cfg80211.c b/drivers/net/wireless/microchip/wilc1000/cfg80211.c
index 016aa062a..5cb67c62e 100644
--- a/drivers/net/wireless/microchip/wilc1000/cfg80211.c
+++ b/drivers/net/wireless/microchip/wilc1000/cfg80211.c
@@ -2113,9 +2113,15 @@ static int del_virtual_intf(struct wiphy *wiphy, struct wireless_dev *wdev)
 	    wdev->iftype == NL80211_IFTYPE_P2P_GO)
 		wilc_wfi_deinit_mon_interface(wl, true);
 	vif = netdev_priv(wdev->netdev);
-	unregister_netdevice(vif->ndev);
 	vif->monitor_flag = 0;
 
+	// If this interface was created by probe()->wilc_cfg80211_init(), then
+	// it was created when the driver was initialized. Only remove()->wilc_netdev_cleanup()
+	// shall be allowed to unregister this interface.
+	if (vif->primary_if) return 0;
+
+	unregister_netdevice(vif->ndev);
+
 	/* update the vif list */
 	mutex_lock(&wl->vif_mutex);
 	/* delete the interface from rcu list */
@@ -2375,6 +2381,7 @@ int wilc_cfg80211_init(struct wilc **wilc, struct device *dev, int io_type,
 		goto free_wq;
 	}
 
+	vif->primary_if = 1;
 	wilc_sysfs_init(wl);
 
 	return 0;
diff --git a/drivers/net/wireless/microchip/wilc1000/debugfs.h b/drivers/net/wireless/microchip/wilc1000/debugfs.h
index 2de82a194..bc195887e 100644
--- a/drivers/net/wireless/microchip/wilc1000/debugfs.h
+++ b/drivers/net/wireless/microchip/wilc1000/debugfs.h
@@ -26,6 +26,8 @@
 #define PWRDEV_DBG		BIT(10)
 #define DBG_REGION_ALL		(BIT(11)-1)
 
+#if defined(WILC_DEBUGFS)
+
 extern atomic_t WILC_DEBUG_REGION;
 
 #define PRINT_D(netdev, region, format, ...) do { \
@@ -49,6 +51,15 @@ extern atomic_t WILC_DEBUG_REGION;
 #define PRINT_ER(netdev, format, ...) netdev_err(netdev, "ERR [%s:%d] "format,\
 	__func__, __LINE__, ##__VA_ARGS__)
 
+#else
+
+#define PRINT_D(netdev, region, format, ...) do { } while (0)
+#define PRINT_INFO(netdev, region, format, ...) do { } while (0)
+#define PRINT_WRN(netdev, region, format, ...) do { } while (0)
+#define PRINT_ER(netdev, format, ...) do { } while (0)
+
+#endif
+
 #ifdef WILC_DEBUGFS
 int wilc_debugfs_init(void);
 void wilc_debugfs_remove(void);
diff --git a/drivers/net/wireless/microchip/wilc1000/netdev.c b/drivers/net/wireless/microchip/wilc1000/netdev.c
index 824afeaca..d6e5d803d 100644
--- a/drivers/net/wireless/microchip/wilc1000/netdev.c
+++ b/drivers/net/wireless/microchip/wilc1000/netdev.c
@@ -31,9 +31,12 @@
 static int wilc_mac_open(struct net_device *ndev);
 static int wilc_mac_close(struct net_device *ndev);
 
-static int debug_running;
 static int recovery_on;
 int wait_for_recovery;
+
+#if defined(WILC_DEBUGFS)
+static int debug_running;
+
 static int debug_thread(void *arg)
 {
 	struct wilc *wl = arg;
@@ -141,6 +144,7 @@ static int debug_thread(void *arg)
 	}
 	return 0;
 }
+#endif
 
 static void wilc_disable_irq(struct wilc *wilc, int wait)
 {
@@ -188,6 +192,9 @@ static int init_irq(struct net_device *dev)
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc *wl = vif->wilc;
 
+	// This is no longer supported, the firmware for the WILC3000 does not yank the IRQN line back to the gpio
+	return 0;
+
 	if (wl->dev_irq_num <= 0)
 		return 0;
 
@@ -328,9 +335,6 @@ static int wilc_txq_task(void *vp)
 
 	complete(&wl->txq_thread_started);
 	while (1) {
-		struct wilc_vif *vif = wilc_get_wl_to_vif(wl);
-		struct net_device *ndev = vif->ndev;
-
 		PRINT_INFO(ndev, TX_DBG, "txq_task Taking a nap\n");
 		if (wait_for_completion_interruptible(&wl->txq_event))
 			continue;
@@ -650,6 +654,7 @@ static void wlan_deinitialize_threads(struct net_device *dev)
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc *wl = vif->wilc;
 
+#if defined(WILC_DEBUGFS)
 	PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing Threads\n");
 	if (!recovery_on) {
 		PRINT_INFO(vif->ndev, INIT_DBG, "Deinit debug Thread\n");
@@ -661,6 +666,7 @@ static void wlan_deinitialize_threads(struct net_device *dev)
 			wl->debug_thread = NULL;
 		}
 	}
+#endif
 
 	wl->close = 1;
 	PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing Threads\n");
@@ -738,6 +744,7 @@ static int wlan_initialize_threads(struct net_device *dev)
 	}
 	wait_for_completion(&wilc->txq_thread_started);
 
+#if defined(WILC_DEBUGFS)
 	if (!debug_running) {
 		PRINT_INFO(vif->ndev, INIT_DBG,
 			   "Creating kthread for Debugging\n");
@@ -752,6 +759,7 @@ static int wlan_initialize_threads(struct net_device *dev)
 		debug_running = true;
 		wait_for_completion(&wilc->debug_thread_started);
 	}
+#endif
 
 	return 0;
 }
diff --git a/drivers/net/wireless/microchip/wilc1000/netdev.h b/drivers/net/wireless/microchip/wilc1000/netdev.h
index f06d45a22..66e234e3d 100644
--- a/drivers/net/wireless/microchip/wilc1000/netdev.h
+++ b/drivers/net/wireless/microchip/wilc1000/netdev.h
@@ -345,6 +345,7 @@ struct wilc_vif {
 	u8 idx;
 	u8 iftype;
 	int monitor_flag;
+	int primary_if;
 	int mac_opened;
 #if KERNEL_VERSION(5, 8, 0) <= LINUX_VERSION_CODE
 	u32 mgmt_reg_stypes;
diff --git a/drivers/net/wireless/microchip/wilc1000/power.c b/drivers/net/wireless/microchip/wilc1000/power.c
index 6c59e0bd1..69df58a59 100644
--- a/drivers/net/wireless/microchip/wilc1000/power.c
+++ b/drivers/net/wireless/microchip/wilc1000/power.c
@@ -57,6 +57,10 @@ int wilc_of_parse_power_pins(struct wilc *wilc)
  */
 void wilc_wlan_power(struct wilc *wilc, bool on)
 {
+	// To late in the game to use these, this will undo the SDIO setup that the Xilinx driver has already done
+	// plus these were moved out of the wilc device tree child node so that pwrseq_simple can properly use them
+	return;
+
 	if (!gpio_is_valid(wilc->power.gpios.chip_en) ||
 	    !gpio_is_valid(wilc->power.gpios.reset)) {
 		/* In case SDIO power sequence driver is used to power this
diff --git a/drivers/net/wireless/microchip/wilc1000/sdio.c b/drivers/net/wireless/microchip/wilc1000/sdio.c
index db6eb4bbe..db6ac7675 100644
--- a/drivers/net/wireless/microchip/wilc1000/sdio.c
+++ b/drivers/net/wireless/microchip/wilc1000/sdio.c
@@ -436,13 +436,22 @@ static int wilc_sdio_write_reg(struct wilc *wilc, u32 addr, u32 data)
 				"Failed cmd 52, write reg (%08x) ...\n", addr);
 	} else {
 		struct sdio_cmd53 cmd;
+		u32 *pdata = kmalloc(sizeof(*pdata), GFP_KERNEL);
+		if (!pdata) {
+		dev_err(&func->dev, "kmalloc fail\n");
+			return 1;
+		}
+
+		*pdata = data;
 
 		/**
 		 *      set the AHB address
 		 **/
 		ret = wilc_sdio_set_func0_csa_address(wilc, addr);
-		if (ret)
+		if (ret) {
+			kfree(pdata);
 			return ret;
+		}
 
 		cmd.read_write = 1;
 		cmd.function = 0;
@@ -450,12 +459,14 @@ static int wilc_sdio_write_reg(struct wilc *wilc, u32 addr, u32 data)
 		cmd.block_mode = 0;
 		cmd.increment = 1;
 		cmd.count = 4;
-		cmd.buffer = (u8 *)&data;
+		cmd.buffer = (u8 *)pdata;
 		cmd.block_size = sdio_priv->block_size;
 		ret = wilc_sdio_cmd53(wilc, &cmd);
 		if (ret)
 			dev_err(&func->dev,
 				"Failed cmd53, write reg (%08x)...\n", addr);
+
+		kfree(pdata);
 	}
 
 	return ret;
@@ -556,10 +567,17 @@ static int wilc_sdio_read_reg(struct wilc *wilc, u32 addr, u32 *data)
 		*data = cmd.data;
 	} else {
 		struct sdio_cmd53 cmd;
+		u32 *pdata = kmalloc(sizeof(*pdata), GFP_KERNEL);
+		if (!pdata) {
+			dev_err(&func->dev, "kmalloc fail\n");
+			return 1;
+		}
 
 		ret = wilc_sdio_set_func0_csa_address(wilc, addr);
-		if (ret)
+		if (ret) {
+			kfree(pdata);
 			return ret;
+		}
 
 		cmd.read_write = 0;
 		cmd.function = 0;
@@ -567,15 +585,18 @@ static int wilc_sdio_read_reg(struct wilc *wilc, u32 addr, u32 *data)
 		cmd.block_mode = 0;
 		cmd.increment = 1;
 		cmd.count = 4;
-		cmd.buffer = (u8 *)data;
+		cmd.buffer = (u8 *)pdata;
 
 		cmd.block_size = sdio_priv->block_size;
 		ret = wilc_sdio_cmd53(wilc, &cmd);
 		if (ret) {
 			dev_err(&func->dev,
 				"Failed cmd53, read reg (%08x)...\n", addr);
+			kfree(pdata);
 			return ret;
 		}
+		*data = *pdata;
+		kfree(pdata);
 	}
 
 	le32_to_cpus(data);
@@ -686,11 +707,7 @@ static int wilc_sdio_init(struct wilc *wilc, bool resume)
 		func->card->host->ios.clock);
 
 	/* Patch for sdio interrupt latency issue */
-	ret = pm_runtime_get_sync(mmc_dev(func->card->host));
-	if (ret < 0) {
-		pm_runtime_put_noidle(mmc_dev(func->card->host));
-		return ret;
-	}
+	pm_runtime_get_sync(mmc_dev(func->card->host));
 
 	init_waitqueue_head(&sdio_intr_waitqueue);
 	sdio_priv->irq_gpio = (wilc->io_type == WILC_HIF_SDIO_GPIO_IRQ);
diff --git a/drivers/net/wireless/microchip/wilc1000/wlan.c b/drivers/net/wireless/microchip/wilc1000/wlan.c
index 3ed49e628..367df6967 100644
--- a/drivers/net/wireless/microchip/wilc1000/wlan.c
+++ b/drivers/net/wireless/microchip/wilc1000/wlan.c
@@ -819,17 +819,20 @@ static void chip_wakeup_wilc3000(struct wilc *wilc, int source)
 	do {
 		hif_func->hif_write_reg(wilc, wakeup_reg, wakeup_reg_val |
 							  wakeup_bit);
+		/* Wait for the chip to stabilize*/
+		usleep_range(1000, 1100);
+
 		/* Check the clock status */
 		hif_func->hif_read_reg(wilc, clk_status_reg,
 				       &clk_status_reg_val);
 
 		/*
 		 * in case of clocks off, wait 1ms, and check it again.
-		 * if still off, wait for another 1ms, for a total wait of 3ms.
+		 * if still off, wait for another 1ms, for a total wait of 6ms.
 		 * If still off, redo the wake up sequence
 		 */
 		while ((clk_status_reg_val & clk_status_bit) == 0 &&
-		       (++trials % 4) != 0) {
+		       (++trials % 6) != 0) {
 			/* Wait for the chip to stabilize*/
 			usleep_range(1000, 1100);
 
@@ -906,23 +909,32 @@ int wilc_wlan_handle_txq(struct wilc *wilc, u32 *txq_count)
 	int ret = 0;
 	int counter;
 	int timeout;
-	u32 vmm_table[WILC_VMM_TBL_SIZE];
+	u32 *vmm_table;
 	u8 ac_pkt_num_to_chip[NQUEUES] = {0, 0, 0, 0};
 	const struct wilc_hif_func *func;
 	int srcu_idx;
 	u8 *txb = wilc->tx_buffer;
 	struct wilc_vif *vif;
 
+	vmm_table = kmalloc(sizeof(*vmm_table) * WILC_VMM_TBL_SIZE, GFP_KERNEL);
+	if (!vmm_table) {
+		PRINT_ER(vif->ndev, "kmalloc fail vmm_table\n");
+		return -1;
+	}
+
 	if (!wilc->txq_entries) {
 		*txq_count = 0;
+		kfree(vmm_table);
 		return 0;
 	}
 
 	if (wilc->quit)
 		goto out_update_cnt;
 
-	if (ac_balance(wilc, ac_desired_ratio))
+	if (ac_balance(wilc, ac_desired_ratio)) {
+		kfree(vmm_table);
 		return -EINVAL;
+	}
 
 	mutex_lock(&wilc->txq_add_to_head_cs);
 
@@ -1231,6 +1243,7 @@ int wilc_wlan_handle_txq(struct wilc *wilc, u32 *txq_count)
 
 out_update_cnt:
 	*txq_count = wilc->txq_entries;
+	kfree(vmm_table);
 	return ret;
 }
 
@@ -1418,6 +1431,7 @@ int wilc_wlan_firmware_download(struct wilc *wilc, const u8 *buffer,
 	wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
 	reg &= ~BIT(10);
 	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GLB_RESET_0, reg);
+	msleep(200);
 	wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
 	if (reg & BIT(10))
 		pr_err("%s: Failed to reset\n", __func__);
diff --git a/drivers/net/wireless/microchip/wilc1000/wlan.h b/drivers/net/wireless/microchip/wilc1000/wlan.h
index c6a1e11d2..007d94cf0 100644
--- a/drivers/net/wireless/microchip/wilc1000/wlan.h
+++ b/drivers/net/wireless/microchip/wilc1000/wlan.h
@@ -250,8 +250,8 @@ static inline bool is_wilc3000(u32 id)
 #define WILC_TX_BUFF_SIZE	(64 * 1024)
 
 #define MODALIAS		"WILC_SPI"
-#define GPIO_NUM_CHIP_EN	94
-#define GPIO_NUM_RESET		60
+#define GPIO_NUM_CHIP_EN	8
+#define GPIO_NUM_RESET		7
 
 #define NQUEUES			4
 #define AC_BUFFER_SIZE		1000
